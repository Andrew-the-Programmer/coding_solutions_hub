J. UnorderedSet+ — База 2024 2 сем. Задание 1. C++ — Яндекс.КонтестВаше участие в соревновании завершено. Вы можете дорешивать задачи и отправлять решения вне соревнования

# J. UnorderedSet+

| Ограничение времени | 2 секунды |
| --- | --- |
| Ограничение памяти | 256.0 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |

[https://gitlab.com/ibr11/cpp_psami_base/-/tree/master/unordered_set](https://gitlab.com/ibr11/cpp_psami_base/-/tree/master/unordered_set)

### Дополнительное задание к задаче UnorderedSet: итерирование

Если выполнено данное задание, добавьте строку `#define ITERATOR_IMPLEMENTED` в произвольном месте решения.

Этот пункт предполагает реализацию поддержки итераторов для `UnorderedSet`:

- Определение типов-членов `Iterator`, `ConstIterator`, `DifferenceType`.
- Определение методов `begin()`, `end()`, `cbegin()`, `cend()`.

Кажется, что нет никаких проблем пройтись по элементам списка и, допустим, вывести их в консоль, или даже написать
итератор для класса `UnorderedSet`. Однако реализация итерирования может быть осложнена тем, что элементы расположены в
разных контейнерах, поэтому логика операции `++` нетривиальная. К тому же, проход по всем элементам таблицы займет
`O(n_buckets + n_elements)` времени (необходимо пройтись по всем корзинам и, если корзина не пуста, пройтись по ее
элементам), что очень неэффективно при `n_buckets` >> `n_elements`. Хочется добиться линейного от числа элементов
обхода, не зависящего от числа корзин (`O(n_elements)`).

Для решения этих проблем используется следующий подход: элементы хранятся в общем списке, при этом элементы
принадлежащие одной корзине лежат последовательно друг за другом. В корзине теперь хранится не список элементов, а
итератор на первый элемент списка, принадлежащей ей. Если корзина пуста, то хранится пустой итератор (сконструированный
по умолчанию).

*Пример:*

```

Пусть хеш таблица устроена следующим образом - [ [0, 1, 2], [], [3, 4], [], [5] ], то есть в корзине 0 расположены
элементы [0, 1, 2], корзина 1 пуста и т.д. Тогда корректный список элементов выглядит, например, так:
[3]<->[4]<->[0]<->[1]<->[2]<->[5]. Массив корзин же выглядит так: 
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5]], где Iterator[] - пустой итератор, а Iterator[i] -
итератор, указывающий на элемент со значением i.

```

Поиск осуществляется линейным проходом от начала корзины до первого элемента не лежащего в ней (это можно определить по
хеш-значению), либо до конца списка, если такого встречено не было. Вставка и удаление осуществляется с помощью методов
`insert` и `erase` для списка по итератору, указанному в корзине, либо с помощью `push_front`, если корзина пуста. При
этом важно аккуратно обновлять итераторы в корзинах при необходимости.

*Пример:*

```

Вернемся к примеру: элементы [3]<->[4]<->[0]<->[1]<->[2]<->[5], корзины
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5] ]. 
Вставим элемент 6 в корзину 0. Для этого вставим его в список перед элементом [0] и обновим итератор на начало:
[3]<->[4]<->[6]<->[0]<->[1]<->[2]<->[5], [ Iterator[6], Iterator[], Iterator[3], Iterator[], Iterator[5] ]
Удаление 3 состоит в удалении [3] из списка и обновлении итератора 2й корзины на [4].
При удалении 5 итератор 4й корзины становится пустым (корзина опустела).
[4]<->[6]<->[0]<->[1]<->[2], [ Iterator[6], Iterator[], Iterator[4], Iterator[], Iterator[] ]

```

Итерирование по хеш таблице при такой реализации эквивалентно итерированию по списку элементов.

*Полезный факт: при перемещении списка или вызова метода `swap` итераторы на элементы списка не инвалидируются.*

### Дополнительное задание (опциональное) : односвязный список

Если выполнено данное задание, добавьте строку `#define FORWARD_LIST_IMPLEMENTED` в произвольном месте решения.

Правда ли, что нам нужен полный функционал двусвязного списка (`std::list`) для корректной реализации хеш-таблицы? При
поиске мы проходимся по элементам корзины в одном направлении 1 раз, аналогично при вставке и удалении. Обход
хеш-таблице так же требует лишь возможности прямого прохода (то есть категории ForwardIterator). Таким образом,
оказывается, что список элементов достаточно хранить в односвязном списке (`std::forward_list`). А если нет разницы, то
зачем платить больше (лишние расходы на хранение и поддержку обратных ссылок)?

Казалось бы, `ctrl+f` `std::list` + замена `std::list -> std::forward_list` = халявные баллы. Однако не все так просто.
Дело в том, что для удаления из односвязного списка недостаточно иметь итератор на элемент, так как он не хранит
ссылки на предыдущий и восстановить связность списка не представляется возможным. Поэтому для удаления необходим
итератор на элемент *предшествующий* удаляемому. Аналогичные проблемы возникают при выполнении операций `insert` и
`splice`. В связи с этим интерфейс `std::forward_list` отличается от интерфейса `std::list` наличием методов
`insert_after`, `erase_after`, `splice_after`.

Хорошо, а как удалить первый элемент списка? Или вставить элемент в начало списка? Для этого в `std::forward_list`
используется специальный итератор `before_begin()`, который указывает на фиктивную вершину в списке, расположенную
непосредственно перед нулевым элементом списка.

В связи с указанным выше, в корзинах должны храниться не итераторы на начала корзин, а итераторы на элементы, стоящие
перед ними.

*Пример:*

```

Хеш-таблица [ [0, 1, 2], [], [3, 4], [], [5] ] теперь представляется односвязным списком
[x]->[3]->[4]->[0]->[1]->[2]->[5], где [x] - фиктивный элемент перед началом списка (before_begin). 
В корзинах хранятся итераторы: [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

```

При вставке и удалении нужно быть внимательным и аккуратно переприсваивать итераторы, так как какая-то из корзин могла
ссылаться на удаляемый элемент.

*Пример:*

```

[x]->[3]->[4]->[0]->[1]->[2]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

Удалим элемент [2]. Несмотря на то, что [2] принадлежит нулевой корзине, его удаление испортит корзину номер 4 (она
ссылается на него, так как он предшествует элементу [5], лежащему в этой корзине). Поэтому необходимо сначала перенести
итератор 4й корзины на элемент [1] (элемент перед [2]) и только потом удалять [2]:
[x]->[3]->[4]->[0]->[1]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[1] ]

```

*Полезный факт: при перемещении односвязного списка или вызова метода `swap` итераторы на элементы списка не
инвалидируются. НО: итератор на элемент before_begin может стать невалидным.*
