 J. UnorderedSet\+ — База 2024 2 сем. Задание 1\. C\+\+ — Яндекс.КонтестВаше участие в соревновании завершено. Вы можете дорешивать задачи и отправлять решения вне соревнования


J. UnorderedSet\+
=================




| Ограничение времени | 2 секунды |
| --- | --- |
| Ограничение памяти | 256\.0 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |






[https://gitlab.com/ibr11/cpp\_psami\_base/\-/tree/master/unordered\_set](https://gitlab.com/ibr11/cpp_psami_base/-/tree/master/unordered_set)


### Дополнительное задание к задаче UnorderedSet: итерирование


Если выполнено данное задание, добавьте строку `#define ITERATOR_IMPLEMENTED` в произвольном месте решения.


Этот пункт предполагает реализацию поддержки итераторов для `UnorderedSet`:


* Определение типов\-членов `Iterator`, `ConstIterator`, `DifferenceType`.
* Определение методов `begin()`, `end()`, `cbegin()`, `cend()`.


Кажется, что нет никаких проблем пройтись по элементам списка и, допустим, вывести их в консоль, или даже написать
 итератор для класса `UnorderedSet`. Однако реализация итерирования может быть осложнена тем, что элементы расположены в
 разных контейнерах, поэтому логика операции `++` нетривиальная. К тому же, проход по всем элементам таблицы займет
 `O(n_buckets + n_elements)` времени (необходимо пройтись по всем корзинам и, если корзина не пуста, пройтись по ее
 элементам), что очень неэффективно при `n_buckets` \>\> `n_elements`. Хочется добиться линейного от числа элементов
 обхода, не зависящего от числа корзин (`O(n_elements)`).
 


Для решения этих проблем используется следующий подход: элементы хранятся в общем списке, при этом элементы
 принадлежащие одной корзине лежат последовательно друг за другом. В корзине теперь хранится не список элементов, а
 итератор на первый элемент списка, принадлежащей ей. Если корзина пуста, то хранится пустой итератор (сконструированный
 по умолчанию).


*Пример:*




```

Пусть хеш таблица устроена следующим образом - [ [0, 1, 2], [], [3, 4], [], [5] ], то есть в корзине 0 расположены
элементы [0, 1, 2], корзина 1 пуста и т.д. Тогда корректный список элементов выглядит, например, так:
[3]<->[4]<->[0]<->[1]<->[2]<->[5]. Массив корзин же выглядит так: 
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5]], где Iterator[] - пустой итератор, а Iterator[i] -
итератор, указывающий на элемент со значением i.

```


Поиск осуществляется линейным проходом от начала корзины до первого элемента не лежащего в ней (это можно определить по
 хеш\-значению), либо до конца списка, если такого встречено не было. Вставка и удаление осуществляется с помощью методов
 `insert` и `erase` для списка по итератору, указанному в корзине, либо с помощью `push_front`, если корзина пуста. При
 этом важно аккуратно обновлять итераторы в корзинах при необходимости.
 


*Пример:*




```

Вернемся к примеру: элементы [3]<->[4]<->[0]<->[1]<->[2]<->[5], корзины
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5] ]. 
Вставим элемент 6 в корзину 0. Для этого вставим его в список перед элементом [0] и обновим итератор на начало:
[3]<->[4]<->[6]<->[0]<->[1]<->[2]<->[5], [ Iterator[6], Iterator[], Iterator[3], Iterator[], Iterator[5] ]
Удаление 3 состоит в удалении [3] из списка и обновлении итератора 2й корзины на [4].
При удалении 5 итератор 4й корзины становится пустым (корзина опустела).
[4]<->[6]<->[0]<->[1]<->[2], [ Iterator[6], Iterator[], Iterator[4], Iterator[], Iterator[] ]

```


Итерирование по хеш таблице при такой реализации эквивалентно итерированию по списку элементов.


*Полезный факт: при перемещении списка или вызова метода `swap` итераторы на элементы списка не инвалидируются.*


### Дополнительное задание (опциональное) : односвязный список


Если выполнено данное задание, добавьте строку `#define FORWARD_LIST_IMPLEMENTED` в произвольном месте решения.


Правда ли, что нам нужен полный функционал двусвязного списка (`std::list`) для корректной реализации хеш\-таблицы? При
 поиске мы проходимся по элементам корзины в одном направлении 1 раз, аналогично при вставке и удалении. Обход
 хеш\-таблице так же требует лишь возможности прямого прохода (то есть категории ForwardIterator). Таким образом,
 оказывается, что список элементов достаточно хранить в односвязном списке (`std::forward_list`). А если нет разницы, то
 зачем платить больше (лишние расходы на хранение и поддержку обратных ссылок)?


Казалось бы, `ctrl+f` `std::list` \+ замена `std::list -> std::forward_list` \= халявные баллы. Однако не все так просто.
 Дело в том, что для удаления из односвязного списка недостаточно иметь итератор на элемент, так как он не хранит
 ссылки на предыдущий и восстановить связность списка не представляется возможным. Поэтому для удаления необходим
 итератор на элемент *предшествующий* удаляемому. Аналогичные проблемы возникают при выполнении операций `insert` и
 `splice`. В связи с этим интерфейс `std::forward_list` отличается от интерфейса `std::list` наличием методов
 `insert_after`, `erase_after`, `splice_after`.
 


Хорошо, а как удалить первый элемент списка? Или вставить элемент в начало списка? Для этого в `std::forward_list`
 используется специальный итератор `before_begin()`, который указывает на фиктивную вершину в списке, расположенную
 непосредственно перед нулевым элементом списка.


В связи с указанным выше, в корзинах должны храниться не итераторы на начала корзин, а итераторы на элементы, стоящие
 перед ними.


*Пример:*




```

Хеш-таблица [ [0, 1, 2], [], [3, 4], [], [5] ] теперь представляется односвязным списком
[x]->[3]->[4]->[0]->[1]->[2]->[5], где [x] - фиктивный элемент перед началом списка (before_begin). 
В корзинах хранятся итераторы: [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

```


При вставке и удалении нужно быть внимательным и аккуратно переприсваивать итераторы, так как какая\-то из корзин могла
 ссылаться на удаляемый элемент.


*Пример:*




```

[x]->[3]->[4]->[0]->[1]->[2]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

Удалим элемент [2]. Несмотря на то, что [2] принадлежит нулевой корзине, его удаление испортит корзину номер 4 (она
ссылается на него, так как он предшествует элементу [5], лежащему в этой корзине). Поэтому необходимо сначала перенести
итератор 4й корзины на элемент [1] (элемент перед [2]) и только потом удалять [2]:
[x]->[3]->[4]->[0]->[1]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[1] ]

```


*Полезный факт: при перемещении односвязного списка или вызова метода `swap` итераторы на элементы списка не
 инвалидируются. НО: итератор на элемент before\_begin может стать невалидным.*




