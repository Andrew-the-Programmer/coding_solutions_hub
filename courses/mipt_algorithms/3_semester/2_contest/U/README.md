U. Гроб гроб кладбище treap — База 2023 3 сем. Задание 1. RMQ/RSQ — Яндекс.КонтестВаше участие в соревновании завершено. Вы можете дорешивать задачи и отправлять решения вне соревнования

# U. Гроб гроб кладбище treap

| Ограничение времени | 3 секунды |
| --- | --- |
| Ограничение памяти | 64.0 Мб |
| Ввод | стандартный ввод или input.txt |
| Вывод | стандартный вывод или output.txt |

Дан массив целых чисел. Необходимо реализовать структуру данных, в которой требуется за O(logn)O(logn) выполнять запросы:

- сумма на подотрезке \[L,R\]\[L,R\] (в задаче принята 00-индексация);
- вставить элемент xx в позицию pospos (т.е. в результате вставки, элемент xx должен оказаться pospos-ым);
- удалить элемент xx, находящийся на позиции ii;
- присвоить элемент xx на подотрезке \[L,R\]\[L,R\];
- прибавить число x на подотрезке \[L,R\]\[L,R\];
- next_permutationnext_permutation на подотрезке \[L,R\]\[L,R\];
- prev_permutationprev_permutation на подотрезке \[L,R\]\[L,R\].

next_permutationnext_permutation и prev_permutationprev_permutation должны работать так же, как одноименные STL-алгоритмы; В частности, next_permutation(\[4,3,2,1\])next_permutation(\[4,3,2,1\]) есть \[1,2,3,4\]\[1,2,3,4\], а не \[4,3,2,1\]\[4,3,2,1\]; Аналогично, prev_permutation(\[1,2,2,2,3,3,4\])=\[4,3,3,2,2,2,1\]prev_permutation(\[1,2,2,2,3,3,4\])=\[4,3,3,2,2,2,1\].

## Формат ввода

В первой строке записано число n(1≤n≤3⋅104)n(1≤n≤3⋅104)  − − количество элементов в массиве. Во второй строке записано nn чисел, не превосходящих по модулю 3⋅1043⋅104  − − исходные значения элементов массива.

В третьей строке записано число q(1≤q≤105)q(1≤q≤105) - количество запросов. В последующих строках записаны сами запросы, по одному на каждой строке.

Запросы задаются в следующем формате:

- 11 LL RR (0≤l≤r(0≤l≤r
  \< arraySize) - найти сумму всех чисел массива на отрезке \[l, r\];
- 22 xx pospos (∣x∣≤3⋅104,0≤pos≤arraySize)(∣x∣≤3⋅104,0≤pos≤arraySize): вставить элемент xx на позицию pospos;
- 33 pospos (0≤pos(0≤pos
  \< arraySize): удалить элемент, находящийся на позиции pospos;
- 44 xx LL RR (∣x∣≤3⋅104,0≤l≤r(∣x∣≤3⋅104,0≤l≤r
  \< arraySize): присвоить элементам на подотрезке \[L,R\]\[L,R\] значение xx;
- 55 xx LL RR (∣x∣≤3⋅104,0≤l≤r(∣x∣≤3⋅104,0≤l≤r
  \< arraySize): прибавить к элементам на подотрезке \[L,R\]\[L,R\] число xx;
- 66 LL RR: выполнить next_permutationnext_permutation на подотрезке \[L,R\]\[L,R\];
- 77 LL RR: выполнить prev_permutationprev_permutation на подотрезке \[L,R\]\[L,R\].

В приведенном описании arraySize −arraySize − размер массива на момент запроса. Иными словами вам гарантируется, что все запросы корректные.

## Формат вывода

Для каждого запроса типа 11 выведите соответствующую сумму в отдельной строке. По выполнении всех запросов, выведите итоговые значения элементов массива также в отдельной строке.

## Пример

| Ввод Скопировать ввод | Вывод Скопировать вывод |
| --- | --- |
| `7 1 2 3 4 5 6 7 8 4 5 1 3 2 3 3 5 2 0 4 7 0 6 6 0 3 3 2 1 1 5 1 0 6 ` | `28 40 5 3 7 6 7 5 7  ` |

## Примечания

"Самое лучшее в жизни - это 10 секунд между стартом (посылкой) и финишем (ОКом), когда ни о чем не думаешь, есть только ты и свобода" (c) Форсаж 8. Их дороги расходятся.

Язык
